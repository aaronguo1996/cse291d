
==================== FINAL INTERFACE ====================
2017-11-27 18:37:03.3471596 UTC

interface main@main:Calc.Base 7103
  interface hash: d75cc9c9c8a3cc55523606062ebcbc77
  ABI hash: ddc776f0b86280963c82d42fe0f25327
  export-list hash: 150cc122bacd06521551bbbd03cb9ef9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: e3d189ab216185ca46e8ec3971f0c29f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Calc.Base.happyError
  Calc.Base.lexer
  Calc.Base.returnP
  Calc.Base.thenP
  Calc.Lexer.runAlex
  Calc.Lexer.tokenToPosN
  Calc.Base.Parser
  Calc.Lexer.AlexPosn
  Calc.Lexer.AlexState{Calc.Lexer.AlexState Calc.Lexer.alex_bpos Calc.Lexer.alex_chr Calc.Lexer.alex_inp Calc.Lexer.alex_pos Calc.Lexer.alex_scd Calc.Lexer.alex_ust}
  Calc.Lexer.Token{Calc.Lexer.Token}
  Calc.Lexer.TokenClass{Calc.Lexer.TokenAssign Calc.Lexer.TokenCB Calc.Lexer.TokenCase Calc.Lexer.TokenCons Calc.Lexer.TokenDiv Calc.Lexer.TokenEOF Calc.Lexer.TokenElse Calc.Lexer.TokenEq Calc.Lexer.TokenFalse Calc.Lexer.TokenGT Calc.Lexer.TokenIf Calc.Lexer.TokenIn Calc.Lexer.TokenInt Calc.Lexer.TokenLT Calc.Lexer.TokenLambda Calc.Lexer.TokenLand Calc.Lexer.TokenLet Calc.Lexer.TokenLor Calc.Lexer.TokenMinus Calc.Lexer.TokenNil Calc.Lexer.TokenNot Calc.Lexer.TokenOB Calc.Lexer.TokenOf Calc.Lexer.TokenPlus Calc.Lexer.TokenRarrow Calc.Lexer.TokenSemi Calc.Lexer.TokenThen Calc.Lexer.TokenTimes Calc.Lexer.TokenTrue Calc.Lexer.TokenVar}
module dependencies: Calc.Lexer
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  Calc.Lexer 7dbed6056303e487ca72fa46faeae277
  exports: b35ab5ebb4f27b39723a377a17a32d01
  Alex 1900f2bd121d092b258877c93f507366
  Alex 85928eaca8bc5a50a498e8aded94cd63
  AlexPn 79d2e08c6fa4ffd2265d396f96fbca16
  AlexPosn 261e8f7425639282fa8fc3ef60a918ec
  AlexState 54102fd1ab62939028bd177d4f9f78aa
  AlexState 958855d46b169f6268de29b399fc0d0f
  Token 9b59ee6b36cb82fccc468a4bfe425d71
  Token 0f0b166dc6e151fdb621803ea219d929
  TokenAssign 72ce8c90aa7d5d8bd694404d4743ef5e
  TokenCB 8d232a66c9e39555c216ad63a361aee7
  TokenCase a5cf1ccad0e0b98a2494a091409ccf44
  TokenClass d54fdde1724412a5e777472730babff5
  TokenCons 2373e1d72c836e782f5e6c2ca21bd421
  TokenDiv 78a7e385096308023887e72572e36464
  TokenEOF b656a6a682a39c182150ea37cedede16
  TokenElse e07f19919837a93edee1391d83067075
  TokenEq 6d2c7bd512525c0aa3e11ab64e73c912
  TokenFalse 5537533bf67a8714d4d6a1157d5a09c4
  TokenGT 09f2c0233dfdcf923590b3815224f85f
  TokenIf ddf51d5522f00732e5d9072b21d9cdac
  TokenIn f5cb3e93462b04cd6f85b48281ecb07f
  TokenInt d3dbecd775da304f1d9cded15701bc13
  TokenLT 9f09363bd2af9c52c9827d27b1d9468d
  TokenLambda c012ff83806244f9656059965ed3c911
  TokenLand 24d3ad87049e3abe7e7ee33ad9c69c9c
  TokenLet 9983a4fb4d85e701c6cff5be205bceba
  TokenLor 2f8d6b4bb7dcedbbce91c6f41a0903a3
  TokenMinus 89fb00184ea0ff476ba3675a52d20db1
  TokenNil 545bdc6525f3934ef573882ec6a5f3ce
  TokenNot 4c67f63f8e432a0256a29682573d1611
  TokenOB dddbaaf00ceb66b0cd48c49d17769289
  TokenOf 25a6a018ad13ccb871d5d825aad4a9da
  TokenPlus c7639af0ec2def109e405a3270718dc6
  TokenRarrow 0f6eda26c88f768255e2fb622116ddf6
  TokenSemi a9185e76b11686fdfdfd62b6f8f1cf9d
  TokenThen aa1e721c3b604a90f445908ddf383c73
  TokenTimes 89f86e73b193390c74965b672c668556
  TokenTrue 381bb963aa07839dbd20acb2094aa483
  TokenVar 151d65dca0f0e975184324570205d926
  alexError 9be378895fe0d59be0e8e7b6669f605c
  alexMonadScan 95a0478f2c23e568b6d147288ce9f926
  alex_bpos fdac846f2697ef595e7c8484f033ffea
  alex_chr 973bcb3892ed80b4ce883c324503b599
  alex_inp dfce1dc1cc8cec5af540fd6777f36665
  alex_pos 5663ddc387ceb2f806dc5083ec2f9a3c
  alex_scd 630450a5dc8be4c24b0da1c53243a6bc
  alex_ust af158bf44658a8c7230fc5ff493bdb37
  runAlex f2397297a02b7292b1a8c09bd40a5fe6
  tokenToPosN 096db349407ccef27cb0025ad00847e2
de764956cb28e08cfe991219bfac2934
  $wa :: GHC.Prim.Int# -> GHC.Prim.Int# -> (# GHC.Base.String #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a ww :: GHC.Prim.Int# ww1 :: GHC.Prim.Int# ->
                 (# GHC.CString.unpackAppendCString#
                      "show-error: "#
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.shows9
                         (case GHC.Show.$wshowSignedInt
                                 0
                                 ww
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.showList__1
                                    (GHC.Show.$fShow(,,)_$sgo
                                       (\ w2 :: GHC.Base.String ->
                                        case GHC.Show.$wshowSignedInt
                                               0
                                               ww1
                                               w2 of ww4 { (#,#) ww5 ww6 ->
                                        GHC.Types.: @ GHC.Types.Char ww5 ww6 })
                                       Calc.Base.happyError3
                                       Calc.Base.happyError2)) of ww4 { (#,#) ww5 ww6 ->
                          GHC.Types.: @ GHC.Types.Char ww5 ww6 })) #)) -}
f4a2d6ef81524e8146eb4895ae26efee
  $wa1 ::
    (Calc.Lexer.Token -> Calc.Base.Parser a)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.ByteString.Lazy.Internal.ByteString
    -> GHC.Prim.Char#
    -> GHC.Prim.Int#
    -> Calc.Lexer.AlexUserState
    -> Data.Either.Either GHC.Base.String (Calc.Lexer.AlexState, a)
  {- Arity: 9,
     Strictness: <L,1*C1(C1(U))><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   w :: Calc.Lexer.Token -> Calc.Base.Parser a
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: Data.ByteString.Lazy.Internal.ByteString
                   ww5 :: GHC.Prim.Char#
                   ww6 :: GHC.Prim.Int#
                   ww7 :: Calc.Lexer.AlexUserState ->
                 case Calc.Lexer.$wa ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 of wild {
                   Data.Either.Left msg
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ (Calc.Lexer.AlexState, a)
                        msg
                   Data.Either.Right ds
                   -> case ds of wild1 { (,) s' a3 ->
                      (w a3) `cast` (Calc.Lexer.NTCo:Alex[0] <a>_R) s' } }) -}
13e7cd43a194e9b6c0b91a4ff7241744
  type Parser a = Calc.Lexer.Alex a
bc9035ebdc07b31bcb5df9df989d293b
  happyError :: Calc.Base.Parser a
  {- Arity: 1, Strictness: <S,1*U(A,U,U,A,A,A,A,A)>m1,
     Unfolding: InlineRule (0, True, True)
                Calc.Base.happyError1
                  `cast`
                (forall a. Sym (Calc.Lexer.NTCo:Alex[0] <a>_R)) -}
852c2356572eec6cc92c1915399bae92
  happyError1 ::
    Calc.Lexer.AlexState
    -> Data.Either.Either GHC.Base.String (Calc.Lexer.AlexState, a)
  {- Arity: 1, Strictness: <S,1*U(A,U,U,A,A,A,A,A)>m1,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a w :: Calc.Lexer.AlexState ->
                 case w of ww { Calc.Lexer.AlexState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 case Calc.Base.$wa @ a ww2 ww3 of ww9 { (##) ww10 ->
                 Data.Either.Left
                   @ GHC.Base.String
                   @ (Calc.Lexer.AlexState, a)
                   ww10 } }) -}
db437b7bfad56dc5b5b8946449b81e47
  happyError2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows8
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8c6f87bffb21a8aec1b3165dff504f8d
  happyError3 :: [GHC.Show.ShowS]
  {- Unfolding: (GHC.Types.:
                   @ GHC.Show.ShowS
                   GHC.Show.$fShowMaybe2
                   (GHC.Types.[] @ GHC.Show.ShowS)) -}
1fe60b7cdb927e7f8e008b7c093cb26b
  lexer ::
    (Calc.Lexer.Token -> Calc.Base.Parser a) -> Calc.Base.Parser a
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U(U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                Calc.Base.lexer1
                  `cast`
                (forall a.
                 <Calc.Lexer.Token -> Calc.Base.Parser a>_R
                 ->_R Sym (Calc.Lexer.NTCo:Alex[0] <a>_R)) -}
ef674d858b26f89a362fafeaf3c2dd58
  lexer1 ::
    (Calc.Lexer.Token -> Calc.Base.Parser a)
    -> Calc.Lexer.AlexState
    -> Data.Either.Either GHC.Base.String (Calc.Lexer.AlexState, a)
  {- Arity: 2, Strictness: <L,1*C1(C1(U))><S,1*U(U,U,U,U,U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   w :: Calc.Lexer.Token -> Calc.Base.Parser a
                   w1 :: Calc.Lexer.AlexState ->
                 case w1 of ww { Calc.Lexer.AlexState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Calc.Base.$wa1 @ a w ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 }) -}
032efc49d0149de723965234ea72f39c
  returnP :: a -> Calc.Base.Parser a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                Calc.Lexer.$fApplicativeAlex4
                  `cast`
                (forall a2. <a2>_R ->_R Sym (Calc.Lexer.NTCo:Alex[0] <a2>_R)) -}
086216429d35111a2e37f74449fce681
  thenP ::
    Calc.Base.Parser a
    -> (a -> Calc.Base.Parser b) -> Calc.Base.Parser b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                Calc.Lexer.$fMonadAlex1
                  `cast`
                (forall a2 b.
                 <Calc.Lexer.Alex a2>_R
                 ->_R <a2 -> Calc.Lexer.Alex b>_R
                 ->_R Sym (Calc.Lexer.NTCo:Alex[0] <b>_R)) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

